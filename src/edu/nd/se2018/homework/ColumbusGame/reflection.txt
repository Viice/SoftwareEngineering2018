The observable design ended up being cleaner than I expected.  If I were to have made this project on my own with no restriction, I would simply have had the event listener in OceanExplorer check for key presses and in response to one, call both the Columbus and pirate move methods.  With the observer pattern, I was able to just register the pirates as observers, and then write something that runs when Columbus updates.  This allowed the pirates direct access to the moving piece, which would be useful if there were more than one things the pirate had to observe, for example, two ships that Columbus has, and allows for less overhead in OceanExplorer.  The ocean map may not have needed to be its own class, in my opinion, but it is fine as-is too.  My favorite part of this assignment was the clean way in which I assigned islands, Columbus, and the pirates to different cells.  I took the first 100 integers, and randomized them, then set the first 10 in line to be islands, the next to be Columbus, and the next two to be pirates.  Doing this both forced all to be in different places, and worked smoothly with the rest of the program, making it easy to turn the number into a x, y pair by dividing by 10 and modding by 10 to get x and y, respectively.

If I had to implement the stretch functionality, I would start with the imaging of the board, as this would be as easy as loading a new image and adding that to the rectangle instead of a blue fill in the OceanMap class.  Next, I would tackle the reset button, which would also not be too difficult.  When the OceanExplorer starts, it initializes all of the other parts.  Because of this, if I needed a reset button, I would add a class for the game as a whole that has a OceanExplorer as part of it.  Upon clicking the reset button, the game would remove the current OceanExplorer and all of its parts, creating a new one, and thus, resetting the game entirely.
